use csv::WriterBuilder;
use log::info;
use std::io::Write;

#[cfg(feature = "pyo3")]
use pyo3::prelude::*;

#[cfg(feature = "pyo3")]
use crate::data_block::typedefs::CsvRecord;

use crate::{
    data_block::{csv_io_error::CsvIOError, typedefs::RawSyntheticData},
    utils::time::ElapsedDurationLogger,
};

#[cfg_attr(feature = "pyo3", pyclass)]
/// Synthetic data generated by the Generator
pub struct GeneratedData {
    /// Synthesized data - headers (index 0) and records indexes 1...
    pub synthetic_data: RawSyntheticData,
    /// `Synthetic data length / Sensitive data length` (header not included)
    pub expansion_ratio: f64,
}

impl GeneratedData {
    /// Returns a new GeneratedData struct with default values
    #[inline]
    pub fn default() -> GeneratedData {
        GeneratedData {
            synthetic_data: RawSyntheticData::default(),
            expansion_ratio: 0.0,
        }
    }

    /// Returns a new GeneratedData struct
    /// # Arguments
    /// * `synthetic_data` - Synthesized data - headers (index 0) and records indexes 1...
    /// * `expansion_ratio` - `Synthetic data length / Sensitive data length` (header not included)
    #[inline]
    pub fn new(synthetic_data: RawSyntheticData, expansion_ratio: f64) -> GeneratedData {
        GeneratedData {
            synthetic_data,
            expansion_ratio,
        }
    }

    #[inline]
    pub fn _write_synthetic_data<T: Write>(
        &self,
        writer: &mut T,
        delimiter: char,
    ) -> Result<(), CsvIOError> {
        let mut wtr = WriterBuilder::new()
            .delimiter(delimiter as u8)
            .from_writer(writer);

        // write header and records
        for r in self.synthetic_data.iter() {
            match wtr.write_record(r.iter().map(|v| v.as_str())) {
                Ok(_) => {}
                Err(err) => return Err(CsvIOError::new(err)),
            };
        }
        Ok(())
    }
}

#[cfg_attr(feature = "pyo3", pymethods)]
impl GeneratedData {
    #[cfg(feature = "pyo3")]
    /// Synthesized data - headers (index 0) and records indexes 1...
    /// This method will clone the data, so its recommended to have its result stored
    /// in a local variable to avoid it being called multiple times
    fn get_synthetic_data(&self) -> Vec<CsvRecord> {
        self.synthetic_data
            .iter()
            .map(|row| row.iter().map(|value| (**value).clone()).collect())
            .collect()
    }

    #[cfg(feature = "pyo3")]
    #[getter]
    /// `Synthetic data length / Sensitive data length` (header not included)
    fn expansion_ratio(&self) -> f64 {
        self.expansion_ratio
    }

    /// Writes the synthesized data to the file system
    /// # Arguments
    /// * `path` - File path to be written
    /// * `delimiter` - Delimiter to use when writing to `path`
    pub fn write_synthetic_data(&self, path: &str, delimiter: char) -> Result<(), CsvIOError> {
        let _duration_logger = ElapsedDurationLogger::new("write synthetic data");

        let mut file = std::io::BufWriter::new(
            std::fs::File::create(path).map_err(|err| CsvIOError::new(csv::Error::from(err)))?,
        );

        info!("writing file {}", path);

        self._write_synthetic_data(&mut file, delimiter)
    }

    /// Generates a CSV string from the synthetic data
    /// # Arguments
    /// * `delimiter` - CSV delimiter to use
    pub fn synthetic_data_to_string(&self, delimiter: char) -> Result<String, CsvIOError> {
        let mut csv_data = Vec::default();

        self._write_synthetic_data(&mut csv_data, delimiter)?;

        Ok(String::from_utf8_lossy(&csv_data).to_string())
    }
}
